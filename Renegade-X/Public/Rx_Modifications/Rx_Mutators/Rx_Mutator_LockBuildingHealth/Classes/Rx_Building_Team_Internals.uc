/*******************************************************************************
 * Rx_Building_Team_Internals generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2015 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Rx_Building_Team_Internals extends Rx_Building_Internals
    notplaceable
    hidecategories(Navigation);

enum BuildingAlarm
{
    BuildingDestroyed,
    BuildingUnderAttack,
    BuildingDestructionImminent,
    BuildingRepaired,
    BuildingAlarm_MAX
};

struct Attacker
{
    var PlayerReplicationInfo PPRI;
    var float DamageDone;

    structdefaultproperties
    {
        PPRI=none
        DamageDone=0.0
    }
};

var int Health;
var bool HealthLocked;
var bool bCanArmorBreak;
var repnotify bool bDestroyed;
var bool bNoPower;
var bool bBuildingRecoverable;
var bool bCanPlayRepaired;
var bool DmgFx_Lvl0On;
var bool DmgFx_Lvl1On;
var bool DmgFx_Lvl2On;
var bool DmgFx_Lvl3On;
var bool DmgFx_Lvl4On;
var bool DmgFx_OnlyLvl1On;
var bool DmgFx_OnlyLvl2On;
var bool DmgFx_OnlyLvl3On;
var bool bInitialDamageLod;
var int HealthMax;
var int BA_HealthMax;
var int TrueHealthMax;
var int Armor;
var int LowHPWarnLevel;
var int RepairedHPLevel;
var int RepairedArmorLevel;
var float SavedDmg;
var const float HealPointsScale;
var const float HDamagePointsScale;
var const float ADamagePointsScale;
var float Destroyed_Score;
var float ArmorResetTime;
var array<Attacker> DamagingParties;
var protected int DestroyerID;
var PlayerReplicationInfo Destroyer;
var name DestructionAnimName;
var float MessageWaitTime;
var float LastBuildingRepairedMessageTime;
var repnotify int DamageLodLevel;
var array<Rx_BuildingAttachment_DmgFx> DmgFx_Lvl0;
var array<Rx_BuildingAttachment_DmgFx> DmgFx_Lvl1;
var array<Rx_BuildingAttachment_DmgFx> DmgFx_Lvl2;
var array<Rx_BuildingAttachment_DmgFx> DmgFx_Lvl3;
var array<Rx_BuildingAttachment_DmgFx> DmgFx_Lvl4;
var array<Rx_BuildingAttachment_DmgFx> DmgFx_OnlyLvl1;
var array<Rx_BuildingAttachment_DmgFx> DmgFx_OnlyLvl2;
var array<Rx_BuildingAttachment_DmgFx> DmgFx_OnlyLvl3;
var const SoundNodeWave FriendlyBuildingSounds[BuildingAlarm];
var const SoundNodeWave EnemyBuildingSounds[BuildingAlarm];

replication
{
    // Pos:0x000
    if(bNetInitial && Role == ROLE_Authority)
        HealthMax, TrueHealthMax

    // Pos:0x020
    if(bNetDirty && Role == ROLE_Authority)
        Armor, DamageLodLevel, 
        Health, bDestroyed, 
        bNoPower
}

simulated event ReplicatedEvent(name VarName)
{
    // End:0x24
    if(VarName == 'bDestroyed')
    {
        PlayDestructionAnimation();
    }
    // End:0x64
    else
    {
        // End:0x51
        if(VarName == 'DamageLodLevel')
        {
            ChangeDamageLodLevel(DamageLodLevel);
        }
        // End:0x64
        else
        {
            super.ReplicatedEvent(VarName);
        }
    }
    //return;    
}

simulated function Init(Rx_Building Visuals, bool isDebug)
{
    // End:0x173
    if(Role == ROLE_Authority)
    {
        // End:0xFB
        if(Rx_Building_Techbuilding(Visuals) == none)
        {
            Visuals.HealthMax = BA_HealthMax;
            Armor = (BA_HealthMax * Rx_Game(WorldInfo.Game).buildingArmorPercentage) / 100;
            Health = BA_HealthMax - Armor;
            HealthMax = BA_HealthMax;
            TrueHealthMax = BA_HealthMax - Armor;
        }
        // End:0x173
        else
        {
            Health = Visuals.HealthMax;
            HealthMax = Visuals.HealthMax;
            TrueHealthMax = Visuals.HealthMax;
        }
    }
    // End:0x212
    if(TeamID == 2)
    {
        LogInternal(string(self.Class) @ "has team set to TEAM_UNOWNED");
        // End:0x212
        if(bBuildingDebug)
        {
            LogInternal(string(self.Class) @ "has team set to TEAM_UNOWNED", 'Buildings');
        }
    }
    super.Init(Visuals, isDebug);
    ChangeDamageLodLevel(DamageLodLevel);
    //return;    
}

simulated function int GetHealth()
{
    return Health;
    //return ReturnValue;    
}

simulated function int GetMaxHealth()
{
    return HealthMax;
    //return ReturnValue;    
}

simulated function int GetTrueMaxHealth()
{
    return TrueHealthMax;
    //return ReturnValue;    
}

simulated function int GetArmor()
{
    return Armor;
    //return ReturnValue;    
}

simulated function int GetMaxArmor()
{
    return int((float(HealthMax) * float(Rx_GRI(WorldInfo.GRI).buildingArmorPercentage)) / 100.0);
    //return ReturnValue;    
}

simulated function bool IsDestroyed()
{
    return bDestroyed;
    //return ReturnValue;    
}

function TakeDamage(int DamageAmount, Controller EventInstigator, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local float CurDmg;
    local int TempDmg;
    local float Scr;
    local int dmgLodLevel;
    local Rx_Controller PC, StarPC;
    local int InstigatorIndex;
    local Attacker TempAttacker, PRII;
    local float StartHealth, StartArmor;

    // End:0x11
    if(HealthLocked)
    {
        return;
    }
    StarPC = Rx_Controller(EventInstigator);
    // End:0xA8
    if(((((GetTeamNum() == EventInstigator.GetTeamNum()) || bDestroyed) || Role < ROLE_Authority) || Health <= 0) || DamageAmount <= 0)
    {
        return;
    }
    StartHealth = float(GetHealth());
    StartArmor = float(GetArmor());
    // End:0xF6
    if(DamageType == none)
    {
        DamageType = class'DamageType';
    }
    // End:0x32C
    if(EventInstigator != none)
    {
        CurDmg = float(DamageAmount);
        // End:0x32C
        if(class<Rx_DmgType>(DamageType) != none)
        {
            // End:0x22E
            if((Rx_Weapon(EventInstigator.Pawn.Weapon) != none) && Rx_Weapon(EventInstigator.Pawn.Weapon).VRank >= 2)
            {
                DamageAmount *= Rx_Weapon(EventInstigator.Pawn.Weapon).Elite_Building_DamageMod;
            }
            CurDmg = float(DamageAmount) * class<Rx_DmgType>(DamageType).static.BuildingDamageScalingFor();
            DamageAmount *= class<Rx_DmgType>(DamageType).static.BuildingDamageScalingFor();
            // End:0x2DA
            if(float(DamageAmount) < CurDmg)
            {
                SavedDmg += (CurDmg - float(DamageAmount));
            }
            // End:0x32C
            if(SavedDmg >= float(1))
            {
                DamageAmount += int(SavedDmg);
                TempDmg = int(SavedDmg);
                SavedDmg -= float(TempDmg);
            }
        }
    }
    DamageAmount = Max(DamageAmount, 0);
    // End:0x76C
    if(Armor > 0)
    {
        // End:0x38B
        if((DamageAmount - Armor) >= 0)
        {
            // End:0x38B
            if(bCanArmorBreak)
            {
                ArmorBreak(EventInstigator);
            }
        }
        // End:0x728
        if((DamageAmount - Armor) > 0)
        {
            InstigatorIndex = DamagingParties.Find('PPRI', EventInstigator.PlayerReplicationInfo);
            // End:0x4E8
            if(InstigatorIndex == -1)
            {
                TempAttacker.PPRI = EventInstigator.PlayerReplicationInfo;
                TempAttacker.DamageDone = float(Min(DamageAmount - Armor, Health));
                Rx_PRI(EventInstigator.PlayerReplicationInfo).AddBuildingDamage(FMin(float(DamageAmount - Armor), float(Health)));
                DamagingParties.AddItem(TempAttacker);
            }
            // End:0x655
            else
            {
                // End:0x5DA
                if(CurDmg <= float(Health + Armor))
                {
                    DamagingParties[InstigatorIndex].DamageDone += float(Min(DamageAmount - Armor, ((GetMaxArmor()) + (GetMaxHealth())) + 10));
                    Rx_PRI(EventInstigator.PlayerReplicationInfo).AddBuildingDamage(FMin(float(DamageAmount - Armor), float(((GetMaxArmor()) + (GetMaxHealth())) + 10)));
                }
                // End:0x655
                else
                {
                    DamagingParties[InstigatorIndex].DamageDone += float(Health);
                    Rx_PRI(EventInstigator.PlayerReplicationInfo).AddBuildingDamage(float(Health));
                }
            }
            // End:0x6B6
            if(float(DamageAmount) > float(Health + Armor))
            {
                Scr = (float(Health) * HDamagePointsScale) + (float(Armor) * ADamagePointsScale);
            }
            // End:0x6F9
            else
            {
                Scr = (float(Armor) * ADamagePointsScale) + (float(DamageAmount - Armor) * HDamagePointsScale);
            }
            Health = Max(Health - (DamageAmount - Armor), 0);
        }
        // End:0x748
        else
        {
            Scr = float(DamageAmount) * ADamagePointsScale;
        }
        Armor = Max(Armor - DamageAmount, 0);
    }
    // End:0xA37
    else
    {
        InstigatorIndex = DamagingParties.Find('PPRI', EventInstigator.PlayerReplicationInfo);
        // End:0x89B
        if(InstigatorIndex == -1)
        {
            TempAttacker.PPRI = EventInstigator.PlayerReplicationInfo;
            TempAttacker.DamageDone = FMin(float(DamageAmount), float(Health));
            Rx_PRI(EventInstigator.PlayerReplicationInfo).AddBuildingDamage(FMin(float(DamageAmount), float(Health)));
            DamagingParties.AddItem(TempAttacker);
        }
        // End:0x9B8
        else
        {
            // End:0x93D
            if(CurDmg <= float(Health + Armor))
            {
                DamagingParties[InstigatorIndex].DamageDone += float(DamageAmount);
                Rx_PRI(EventInstigator.PlayerReplicationInfo).AddBuildingDamage(float(DamageAmount));
            }
            // End:0x9B8
            else
            {
                DamagingParties[InstigatorIndex].DamageDone += float(Health);
                Rx_PRI(EventInstigator.PlayerReplicationInfo).AddBuildingDamage(float(Health));
            }
        }
        // End:0x9F6
        if(float(DamageAmount) > float(Health))
        {
            Scr = float(Health) * HDamagePointsScale;
        }
        // End:0xA16
        else
        {
            Scr = float(DamageAmount) * HDamagePointsScale;
        }
        Health = Max(Health - DamageAmount, 0);
    }
    // End:0xB3F
    if((GetTeamNum() != EventInstigator.GetTeamNum()) && Rx_PRI(EventInstigator.PlayerReplicationInfo) != none)
    {
        Rx_PRI(EventInstigator.PlayerReplicationInfo).AddScoreToPlayerAndTeam(Scr);
        Rx_PRI(EventInstigator.PlayerReplicationInfo).AddBuildingDamagePoints(float(Min(DamageAmount, int(StartHealth + StartArmor))));
    }
    // End:0x112D
    if(Health <= 0)
    {
        bDestroyed = true;
        Destroyer = EventInstigator.PlayerReplicationInfo;
        BroadcastLocalizedMessage(MessageClass, 0, EventInstigator.PlayerReplicationInfo,, self);
        // End:0xDB6
        foreach DamagingParties(PRII,)
        {
            // End:0xDB5
            if(PRII.PPRI != none)
            {
                Rx_PRI(PRII.PPRI).AddScoreToPlayerAndTeam(default.Destroyed_Score * (PRII.DamageDone / float(TrueHealthMax)));
                // End:0xD76
                if((Rx_Controller(PRII.PPRI.Owner) != none) && Rx_Pawn(Rx_Controller(PRII.PPRI.Owner).Pawn) != none)
                {
                    Rx_Pawn(Rx_Controller(PRII.PPRI.Owner).Pawn).SetTimer(2.0, false, 'PlayBuildingKillTimer');
                }
                Destroyed_Score -= (default.Destroyed_Score * (PRII.DamageDone / float(TrueHealthMax)));
            }            
        }        
        // End:0xE1D
        if(Destroyed_Score > float(0))
        {
            Rx_TeamInfo(Destroyer.Team).AddRenScore(Destroyed_Score);
            Destroyed_Score = 0.0;
        }
        // End:0x1089
        foreach WorldInfo.AllControllers(class'Rx_Controller', PC)
        {
            // End:0xECB
            if(StarPC == none)
            {
                PC.CTextMessage(Caps(("The" @ BuildingVisuals.GetHumanReadableName()) @ "was destroyed!"), 'Red', 180.0);
                // End:0x1088
                continue;
            }
            // End:0x1020
            if(PC.GetTeamNum() == StarPC.GetTeamNum())
            {
                PC.CTextMessage(Caps(("The" @ BuildingVisuals.GetHumanReadableName()) @ "was destroyed!"), 'Green', 180.0);
                PC.DisseminateVPString(("[Team Building Kill Bonus]&" $ string(float(class'Rx_VeterancyModifiers'.default.Ev_BuildingDestroyed) * Rx_Game(WorldInfo.Game).CurrentBuildingVPModifier)) $ "&");
                // End:0x1088
                continue;
            }
            PC.CTextMessage(Caps(("The" @ BuildingVisuals.GetHumanReadableName()) @ "was destroyed!"), 'Red', 180.0);            
        }        
        Rx_Game(WorldInfo.Game).LogBuildingDestroyed(Destroyer, self, DamageType);
        PlayDestructionAnimation();
        Rx_Game(WorldInfo.Game).CheckBuildingsDestroyed(BuildingVisuals);
    }
    // End:0x114F
    else
    {
        // End:0x114F
        if(DamageAmount > 0)
        {
            TriggerBuildingUnderAttackMessage(EventInstigator);
        }
    }
    // End:0x1183
    if(!bCanPlayRepaired && Armor <= RepairedArmorLevel)
    {
        bCanPlayRepaired = true;
    }
    dmgLodLevel = GetBuildingHealthLod();
    // End:0x11D4
    if(dmgLodLevel != DamageLodLevel)
    {
        DamageLodLevel = dmgLodLevel;
        ChangeDamageLodLevel(dmgLodLevel);
    }
    super(Actor).TakeDamage(DamageAmount, EventInstigator, HitLocation, Momentum, DamageType, HitInfo, DamageCauser);
    // End:0x12A8
    if(bBuildingDebug)
    {
        LogInternal(((((((string(self.Class) @ "taking") @ string(DamageAmount)) @ "damage.") @ string(SavedDmg)) @ "damage saved -") @ string(Health)) @ "remaining", 'Buildings');
    }
    //return;    
}

function TriggerBuildingUnderAttackMessage(Controller EventInstigator)
{
    // End:0x7E
    if(Rx_Game(WorldInfo.Game).CanPlayBuildingUnderAttackMessage(GetTeamNum()))
    {
        BroadcastLocalizedMessage(MessageClass, 1, EventInstigator.PlayerReplicationInfo,, self);
    }
    Rx_Game(WorldInfo.Game).ResetBuildingUnderAttackEvaTimer(GetTeamNum());
    //return;    
}

function bool HealDamage(int Amount, Controller Healer, class<DamageType> DamageType)
{
    local int RealAmount;
    local float Scr;
    local int dmgLodLevel, repairableHealth, repairableMaxHealth;
    local bool bRepairArmor;

    // End:0x87
    if(Rx_Building_TechBuilding_Internals(self) == none)
    {
        bRepairArmor = true;
        repairableHealth = Armor;
        repairableMaxHealth = (HealthMax * Rx_Game(WorldInfo.Game).buildingArmorPercentage) / 100;
    }
    // End:0xAD
    else
    {
        repairableHealth = Health;
        repairableMaxHealth = HealthMax;
    }
    Amount = Amount * 2;
    // End:0x4F1
    if(((((bRepairArmor || repairableHealth > 0) && repairableHealth < repairableMaxHealth) && Amount > 0) && Healer != none) && Healer.GetTeamNum() == GetTeamNum())
    {
        RealAmount = Min(Amount, repairableMaxHealth - repairableHealth);
        // End:0x338
        if(RealAmount > 0)
        {
            // End:0x289
            if((repairableHealth >= repairableMaxHealth) && SavedDmg > 0.0)
            {
                SavedDmg = FMax(0.0, SavedDmg - float(Amount));
                Scr = SavedDmg * HealPointsScale;
                Rx_PRI(Healer.PlayerReplicationInfo).AddScoreToPlayerAndTeam(Scr);
                Rx_PRI(Healer.PlayerReplicationInfo).AddRepairPoints_B(float(RealAmount));
            }
            Scr = float(RealAmount) * HealPointsScale;
            Rx_PRI(Healer.PlayerReplicationInfo).AddScoreToPlayerAndTeam(Scr);
            Rx_PRI(Healer.PlayerReplicationInfo).AddRepairPoints_B(float(RealAmount));
        }
        // End:0x384
        if(bRepairArmor)
        {
            Armor = Min(repairableMaxHealth, Armor + Amount);
            repairableHealth = Armor;
        }
        // End:0x3C0
        else
        {
            Health = Min(repairableMaxHealth, Health + Amount);
            repairableHealth = Health;
        }
        // End:0x49E
        if(repairableHealth >= repairableMaxHealth)
        {
            // End:0x492
            if(((RealAmount > 0) && (WorldInfo.TimeSeconds - LastBuildingRepairedMessageTime) > float(10)) && bCanPlayRepaired)
            {
                BroadcastLocalizedTeamMessage(GetTeamNum(), MessageClass, 3, Healer.PlayerReplicationInfo,, self);
                LastBuildingRepairedMessageTime = WorldInfo.TimeSeconds;
            }
            bCanPlayRepaired = false;
        }
        dmgLodLevel = GetBuildingHealthLod();
        // End:0x4EF
        if(dmgLodLevel != DamageLodLevel)
        {
            DamageLodLevel = dmgLodLevel;
            ChangeDamageLodLevel(dmgLodLevel);
        }
        return true;
    }
    return false;
    //return ReturnValue;    
}

function int GetBuildingHealthLod()
{
    local int Perc;

    // End:0x20
    if((Health + Armor) <= 0)
    {
        return 4;
    }
    // End:0x45
    else
    {
        // End:0x45
        if((Health + Armor) == (GetMaxHealth()))
        {
            return 1;
        }
    }
    Perc = (Health + Armor) / ((GetMaxHealth()) / 100);
    // End:0xB0
    if(Perc > 66)
    {
        // End:0xAB
        if(DamageLodLevel == 2)
        {
            // End:0xA8
            if(Perc >= 80)
            {
                return 1;
            }
            // End:0xAB
            else
            {
                return 2;
            }
        }
        return 1;
    }
    // End:0x101
    else
    {
        // End:0xEF
        if(Perc > 33)
        {
            // End:0xE9
            if(DamageLodLevel == 3)
            {
                // End:0xE6
                if(Perc >= 50)
                {
                    return 2;
                }
                // End:0xE9
                else
                {
                    return 3;
                }
            }
            return 2;
        }
        // End:0x101
        else
        {
            // End:0x101
            if(Perc >= 0)
            {
                return 3;
            }
        }
    }
    return (Health + Armor) / 400;
    //return ReturnValue;    
}

simulated function ChangeDamageLodLevel(int newDmgLodLevel)
{
    local int I;

    // End:0x22A
    if(WorldInfo.NetMode != NM_DedicatedServer)
    {
        I = 0;
        J0x34:
        // End:0xF5 [Loop If]
        if(I < BuildingVisuals.StaticMeshPieces.Length)
        {
            BuildingVisuals.StaticMeshPieces[I].ForcedLodModel = newDmgLodLevel;
            BuildingVisuals.StaticMeshPieces[I].ForceUpdate(true);
            ++ I;
            // [Loop Continue]
            goto J0x34;
        }
        // End:0x113
        if(newDmgLodLevel >= 1)
        {
            DmgFxEnableLevel(1, true);
        }
        // End:0x11F
        else
        {
            DmgFxEnableLevel(1, false);
        }
        // End:0x13F
        if(newDmgLodLevel >= 2)
        {
            DmgFxEnableLevel(2, true);
        }
        // End:0x14C
        else
        {
            DmgFxEnableLevel(2, false);
        }
        // End:0x16C
        if(newDmgLodLevel >= 3)
        {
            DmgFxEnableLevel(3, true);
        }
        // End:0x179
        else
        {
            DmgFxEnableLevel(3, false);
        }
        // End:0x1A5
        if(newDmgLodLevel >= 4)
        {
            DmgFxEnableLevel(4, true);
            DmgFxEnableLevel(0, false);
        }
        // End:0x1BE
        else
        {
            DmgFxEnableLevel(4, false);
            DmgFxEnableLevel(0, true);
        }
        DmgFxEnableLevel(-1, newDmgLodLevel == 1);
        DmgFxEnableLevel(-2, newDmgLodLevel == 2);
        DmgFxEnableLevel(-3, newDmgLodLevel == 3);
        // End:0x22A
        if(bInitialDamageLod)
        {
            bInitialDamageLod = false;
        }
    }
    //return;    
}

simulated function DmgFxEnableLevel(int lvl, bool on)
{
    local Rx_BuildingAttachment_DmgFx FX;

    switch(lvl)
    {
        // End:0xD4
        case 0:
            // End:0x32
            if(DmgFx_Lvl0On == on)
            {
                return;
            }
            // End:0x84
            if(on)
            {
                // End:0x80
                foreach DmgFx_Lvl0(FX,)
                {
                    FX.TurnOn(bInitialDamageLod);                    
                }                
            }
            // End:0xBC
            else
            {
                // End:0xBB
                foreach DmgFx_Lvl0(FX,)
                {
                    FX.TurnOff();                    
                }                
            }
            DmgFx_Lvl0On = on;
            // End:0x62D
            break;
        // End:0x195
        case 1:
            // End:0xF3
            if(DmgFx_Lvl1On == on)
            {
                return;
            }
            // End:0x145
            if(on)
            {
                // End:0x141
                foreach DmgFx_Lvl1(FX,)
                {
                    FX.TurnOn(bInitialDamageLod);                    
                }                
            }
            // End:0x17D
            else
            {
                // End:0x17C
                foreach DmgFx_Lvl1(FX,)
                {
                    FX.TurnOff();                    
                }                
            }
            DmgFx_Lvl1On = on;
            // End:0x62D
            break;
        // End:0x257
        case 2:
            // End:0x1B5
            if(DmgFx_Lvl2On == on)
            {
                return;
            }
            // End:0x207
            if(on)
            {
                // End:0x203
                foreach DmgFx_Lvl2(FX,)
                {
                    FX.TurnOn(bInitialDamageLod);                    
                }                
            }
            // End:0x23F
            else
            {
                // End:0x23E
                foreach DmgFx_Lvl2(FX,)
                {
                    FX.TurnOff();                    
                }                
            }
            DmgFx_Lvl2On = on;
            // End:0x62D
            break;
        // End:0x319
        case 3:
            // End:0x277
            if(DmgFx_Lvl3On == on)
            {
                return;
            }
            // End:0x2C9
            if(on)
            {
                // End:0x2C5
                foreach DmgFx_Lvl3(FX,)
                {
                    FX.TurnOn(bInitialDamageLod);                    
                }                
            }
            // End:0x301
            else
            {
                // End:0x300
                foreach DmgFx_Lvl3(FX,)
                {
                    FX.TurnOff();                    
                }                
            }
            DmgFx_Lvl3On = on;
            // End:0x62D
            break;
        // End:0x3DB
        case 4:
            // End:0x339
            if(DmgFx_Lvl4On == on)
            {
                return;
            }
            // End:0x38B
            if(on)
            {
                // End:0x387
                foreach DmgFx_Lvl4(FX,)
                {
                    FX.TurnOn(bInitialDamageLod);                    
                }                
            }
            // End:0x3C3
            else
            {
                // End:0x3C2
                foreach DmgFx_Lvl4(FX,)
                {
                    FX.TurnOff();                    
                }                
            }
            DmgFx_Lvl4On = on;
            // End:0x62D
            break;
        // End:0x4A0
        case -1:
            // End:0x3FE
            if(DmgFx_OnlyLvl1On == on)
            {
                return;
            }
            // End:0x450
            if(on)
            {
                // End:0x44C
                foreach DmgFx_OnlyLvl1(FX,)
                {
                    FX.TurnOn(bInitialDamageLod);                    
                }                
            }
            // End:0x488
            else
            {
                // End:0x487
                foreach DmgFx_OnlyLvl1(FX,)
                {
                    FX.TurnOff();                    
                }                
            }
            DmgFx_OnlyLvl1On = on;
            // End:0x62D
            break;
        // End:0x565
        case -2:
            // End:0x4C3
            if(DmgFx_OnlyLvl2On == on)
            {
                return;
            }
            // End:0x515
            if(on)
            {
                // End:0x511
                foreach DmgFx_OnlyLvl2(FX,)
                {
                    FX.TurnOn(bInitialDamageLod);                    
                }                
            }
            // End:0x54D
            else
            {
                // End:0x54C
                foreach DmgFx_OnlyLvl2(FX,)
                {
                    FX.TurnOff();                    
                }                
            }
            DmgFx_OnlyLvl2On = on;
            // End:0x62D
            break;
        // End:0x62A
        case -3:
            // End:0x588
            if(DmgFx_OnlyLvl3On == on)
            {
                return;
            }
            // End:0x5DA
            if(on)
            {
                // End:0x5D6
                foreach DmgFx_OnlyLvl3(FX,)
                {
                    FX.TurnOn(bInitialDamageLod);                    
                }                
            }
            // End:0x612
            else
            {
                // End:0x611
                foreach DmgFx_OnlyLvl3(FX,)
                {
                    FX.TurnOff();                    
                }                
            }
            DmgFx_OnlyLvl3On = on;
            // End:0x62D
            break;
        // End:0xFFFF
        default:
            //return;
    }    
}

simulated function AddDmgFx(Rx_BuildingAttachment_DmgFx FX, int Level)
{
    switch(Level)
    {
        // End:0x30
        case 0:
            DmgFx_Lvl0.AddItem(FX);
            // End:0x188
            break;
        // End:0x4D
        case 1:
            DmgFx_Lvl1.AddItem(FX);
            // End:0x188
            break;
        // End:0x6B
        case 2:
            DmgFx_Lvl2.AddItem(FX);
            // End:0x188
            break;
        // End:0x89
        case 3:
            DmgFx_Lvl3.AddItem(FX);
            // End:0x188
            break;
        // End:0x8E
        case 4:
        // End:0xAF
        case -4:
            DmgFx_Lvl4.AddItem(FX);
            // End:0x188
            break;
        // End:0xD0
        case -1:
            DmgFx_OnlyLvl1.AddItem(FX);
            // End:0x188
            break;
        // End:0xF1
        case -2:
            DmgFx_OnlyLvl2.AddItem(FX);
            // End:0x188
            break;
        // End:0x112
        case -3:
            DmgFx_OnlyLvl3.AddItem(FX);
            // End:0x188
            break;
        // End:0xFFFF
        default:
            LogInternal((((("DMGFX ERROR -" @ string(FX)) @ "(") $ FX.SocketPattern) $ ") was not added to a DmgFx array in") @ string(self));
            // End:0x188
            break;
    }
    //return;    
}

function PowerLost()
{
    bNoPower = true;
    //return;    
}

function bool PowerRestore()
{
    local Rx_Building_PowerFactory Building;

    // End:0x95
    foreach AllActors(class'Rx_Building_PowerFactory', Building)
    {
        // End:0x50
        if(TeamID != Building.TeamID)
        {
            continue;            
            // End:0x94
            continue;
        }
        // End:0x94
        if(!Building.IsDestroyed() && !bDestroyed)
        {
            bNoPower = false;            
            return true;
        }        
    }    
    return false;
    //return ReturnValue;    
}

simulated function PlayDestructionAnimation()
{
    // End:0x56
    if((WorldInfo.NetMode == NM_DedicatedServer) || WorldInfo.NetMode == NM_ListenServer)
    {
        return;
    }
    // End:0xCC
    if(BuildingSkeleton.FindAnimSequence(DestructionAnimName) == none)
    {
        LogInternal("CLIENT - PlayDestructionAnimation() refused - no animation found!");
        return;
    }
    // End:0x117
    if(bBuildingDebug)
    {
        LogInternal(("Playing Destruction Animation (" $ string(DestructionAnimName)) $ ")", 'Buildings');
    }
    BuildingSkeleton.PlayAnim(DestructionAnimName);
    ((bBuildingRecoverable) ? GotoState('IsDestroyedRecoverable') : GotoState('IsDestroyedIgnoreAll'));
    //return;    
}

simulated function SoundNodeWave GetAnnouncment(int alarm, int TeamNum)
{
    // End:0x31
    if(TeamNum == GetTeamNum())
    {
        return FriendlyBuildingSounds[alarm];
    }
    // End:0x45
    else
    {
        return EnemyBuildingSounds[alarm];
    }
    //return ReturnValue;    
}

static function string GetLocalString(optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2)
{
    local string Str;

    // End:0x11F
    if(Switch == 0)
    {
        // End:0xA0
        if(FRand() < 0.50)
        {
            Str = Repl(class'Rx_Message_Buildings'.default.BuildingBroadcastMessages[0], "`PlayerName`", RelatedPRI_1.PlayerName);
            return Repl(Str, "`BuildingName`", default.BuildingName);
        }
        // End:0x11F
        else
        {
            Str = Repl(class'Rx_Message_Buildings'.default.BuildingBroadcastMessages[1], "`PlayerName`", RelatedPRI_1.PlayerName);
            return Repl(Str, "`BuildingName`", default.BuildingName);
        }
    }
    return "";
    //return ReturnValue;    
}

function ArmorBreak(Controller Con)
{
    local Rx_Controller PC;

    // End:0xD9
    foreach WorldInfo.AllControllers(class'Rx_Controller', PC)
    {
        // End:0xD8
        if(PC.GetTeamNum() == Con.GetTeamNum())
        {
            PC.DisseminateVPString(("[Armour Break Bonus]&" $ string(class'Rx_VeterancyModifiers'.default.Ev_BuildingArmorBreak)) $ "&");
        }        
    }    
    bCanArmorBreak = false;
    SetTimer(ArmorResetTime, false, 'ResetArmorBreakEventTimer');
    //return;    
}

function ResetArmorBreakEventTimer()
{
    bCanArmorBreak = true;
    //return;    
}

simulated state IsDestroyedIgnoreAll
{
    ignores Touch, UnTouch, TakeDamage, HealDamage, BeginState;
    stop;    
}

simulated state IsDestroyedRecoverable
{
    ignores Touch, UnTouch, BeginState;
    stop;    
}

defaultproperties
{
    bCanArmorBreak=true
    bInitialDamageLod=true
    HealthMax=4000
    BA_HealthMax=4800
    LowHPWarnLevel=200
    RepairedHPLevel=3400
    RepairedArmorLevel=1200
    HealPointsScale=0.040
    HDamagePointsScale=0.50
    ADamagePointsScale=0.050
    Destroyed_Score=1000.0
    ArmorResetTime=300.0
    DestructionAnimName=BuildingDeath
    MessageWaitTime=15.0
    DamageLodLevel=1
    begin object name=BuildingSkeletalMeshComponent class=SkeletalMeshComponent
        Animations=AnimNodeSequence'Default__Rx_Building_Team_Internals.BuildingSkeletalMeshComponent.AnimNodeSeq0'
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__Rx_Building_Team_Internals.MyLightEnvironment'
    object end
    // Reference: SkeletalMeshComponent'Default__Rx_Building_Team_Internals.BuildingSkeletalMeshComponent'
    BuildingSkeleton=BuildingSkeletalMeshComponent
    LightEnvironment=DynamicLightEnvironmentComponent'Default__Rx_Building_Team_Internals.MyLightEnvironment'
    TeamID=Team.None
    Components(0)=DynamicLightEnvironmentComponent'Default__Rx_Building_Team_Internals.MyLightEnvironment'
    begin object name=BuildingSkeletalMeshComponent class=SkeletalMeshComponent
        Animations=AnimNodeSequence'Default__Rx_Building_Team_Internals.BuildingSkeletalMeshComponent.AnimNodeSeq0'
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__Rx_Building_Team_Internals.MyLightEnvironment'
    object end
    // Reference: SkeletalMeshComponent'Default__Rx_Building_Team_Internals.BuildingSkeletalMeshComponent'
    Components(1)=BuildingSkeletalMeshComponent
    begin object name=BuildingSkeletalMeshComponent class=SkeletalMeshComponent
        Animations=AnimNodeSequence'Default__Rx_Building_Team_Internals.BuildingSkeletalMeshComponent.AnimNodeSeq0'
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__Rx_Building_Team_Internals.MyLightEnvironment'
    object end
    // Reference: SkeletalMeshComponent'Default__Rx_Building_Team_Internals.BuildingSkeletalMeshComponent'
    CollisionComponent=BuildingSkeletalMeshComponent
    MessageClass=class'Rx_Message_Buildings'
}